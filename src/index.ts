import {
  SchemaResponse,
  ObjectType,
  FunctionInfo,
  ProcedureInfo,
  QueryRequest,
  QueryResponse,
  MutationRequest,
  MutationResponse,
  CapabilitiesResponse,
  ExplainResponse,
  start,
  Connector,
  InternalServerError,
  ForeignKeyConstraint,
  UniquenessConstraint,
  Forbidden,
} from "@hasura/ndc-sdk-typescript";
import { CAPABILITIES_RESPONSE } from "./constants";
import { doQuery } from "./handlers/query";
import { doExplain } from "./handlers/explain";
import { doGetSchema } from "./handlers/schema";
import { GraphQLSchema } from "graphql";
import { readFileSync } from "fs";
import { Neo4jGraphQL } from "@neo4j/graphql";
import { Neo4j } from "./neo4j";

export interface ConfigurationSchema {
  collection_names: string[];
  object_fields: { [k: string]: string[] };
  object_types: { [k: string]: ObjectType };
  foreign_keys: { [k: string]: { [k: string]: ForeignKeyConstraint } };
  uniqueness_constraints: {
    [k: string]: { [k: string]: UniquenessConstraint };
  };
  functions: FunctionInfo[];
  procedures: ProcedureInfo[];
}

export interface RawConfiguration {}
export interface Configuration {
  /**
   * Typedefs generated by @neo4j/introspector from the database with above credentials.
   * Will be run into an executable GraphQL schema.
   */
  typeDefs: string;
  /**
   * This is the Neo4jGraphQL executable schema to be used when resolving requests.
   * It corresponds to the typedefs.
   */
  config?: ConfigurationSchema;
}

export interface State {
  neo4jInstance: Neo4j;
  neoSchema: GraphQLSchema;
}

const connector: Connector<Configuration, State> = {
  /**
   * Initialize the connector's in-memory state.
   *
   * For example, any connection pools, prepared queries,
   * or other managed resources would be allocated here.
   *
   * In addition, this function should register any
   * connector-specific metrics with the metrics registry.
   * @param configuration
   * @param metrics
   */
  async tryInitState(
    configuration: Configuration,
    _metrics: unknown
  ): Promise<State> {
    const neo4j = Neo4j.getInstance();
    const { typeDefs } = configuration;
    const neo4jGQL = new Neo4jGraphQL({
      typeDefs,
      driver: neo4j.getDriver(),
    });
    const neoSchema = await neo4jGQL.getSchema();
    return Promise.resolve({ neo4jInstance: neo4j, neoSchema });
  },

  /**
   * Get the connector's capabilities.
   *
   * This function implements the [capabilities endpoint](https://hasura.github.io/ndc-spec/specification/capabilities.html)
   * from the NDC specification.
   *
   * This function should be synchronous
   * @param configuration
   */
  getCapabilities(_: Configuration): CapabilitiesResponse {
    return CAPABILITIES_RESPONSE;
  },

  /**
   * Validate the configuration files provided by the user, returning a validated 'Configuration',
   * or throwing an 'Error'. Throwing an error prevents Connector startup.
   * @param configuration
   */
  async parseConfiguration(configurationDir: string): Promise<Configuration> {
    try {
      const configLocation = `${configurationDir}configuration.json`;
      const fileContent = readFileSync(configLocation, "utf8");
      const configObject: Configuration = JSON.parse(fileContent);
      return Promise.resolve(configObject);
    } catch (error) {
      console.error("Failed to parse configuration:", error);
      throw new Forbidden(
        "Internal Server Error, server configuration is invalid",
        {}
      );
    }
  },

  /**
   * Get the connector's schema.
   *
   * This function implements the [schema endpoint](https://hasura.github.io/ndc-spec/specification/schema/index.html)
   * from the NDC specification.
   * @param configuration
   */
  async getSchema(configuration: Configuration): Promise<SchemaResponse> {
    if (!configuration.config) {
      throw new Forbidden("Invalid Configuration", {});
    }
    return Promise.resolve(doGetSchema(configuration.config));
  },

  /**
   * Explain a query by creating an execution plan
   *
   * This function implements the [explain endpoint](https://hasura.github.io/ndc-spec/specification/explain.html)
   * from the NDC specification.
   * @param configuration
   * @param state
   * @param request
   */
  async queryExplain(
    configuration: Configuration,
    _: State,
    request: QueryRequest
  ): Promise<ExplainResponse> {
    if (!configuration.config) {
      throw new Forbidden("Invalid Configuration", {});
    }
    return doExplain(request, configuration.config);
  },

  /**
   * Execute a query
   *
   * This function implements the [query endpoint](https://hasura.github.io/ndc-spec/specification/queries/index.html)
   * from the NDC specification.
   * @param configuration
   * @param state
   * @param request
   */
  async query(
    configuration: Configuration,
    state: State,
    request: QueryRequest
  ): Promise<QueryResponse> {
    if (!configuration.config) {
      throw new Forbidden("Invalid Configuration", {});
    }
    const { config } = configuration;
    const x = await Promise.all(
      request.variables
        ? request.variables.map((v: { [k: string]: unknown }) =>
            doQuery({
              query: request,
              state,
              config,
              variables: v,
            })
          )
        : [doQuery({ query: request, state, config })]
    );
    console.log("resp", JSON.stringify(x, null, 2));
    return x;
  },

  /**
   * Explain a mutation by creating an execution plan
   *
   * This function implements the [explain endpoint](https://hasura.github.io/ndc-spec/specification/explain.html)
   * from the NDC specification.
   * @param configuration
   * @param state
   * @param request
   */
  mutationExplain(
    configuration: Configuration,
    state: State,
    request: MutationRequest
  ): Promise<ExplainResponse> {
    throw new Error("Mutation explain endpoint not implemented!");
  },

  /**
   * Execute a mutation
   *
   * This function implements the [mutation endpoint](https://hasura.github.io/ndc-spec/specification/mutations/index.html)
   * from the NDC specification.
   * @param configuration
   * @param state
   * @param request
   */
  mutation(
    configuration: Configuration,
    state: State,
    request: MutationRequest
  ): Promise<MutationResponse> {
    throw new Error("Mutation endpoint not implemented!");
  },

  /**
   * Check the health of the connector.
   *
   * For example, this function should check that the connector
   * is able to reach its data source over the network.
   * @param configuration
   * @param state
   */
  async healthCheck(_: Configuration, state: State): Promise<undefined> {
    try {
      const driver = state.neo4jInstance.getDriver();
      const canReachServer = driver.getServerInfo();
      console.log("Connection established");
      console.log(canReachServer);
      return Promise.resolve(undefined);
    } catch (err) {
      throw new InternalServerError(`Connection error ${err}`);
    }
  },

  /**
   *
   * Update any metrics from the state
   *
   * Note: some metrics can be updated directly, and do not
   * need to be updated here. This function can be useful to
   * query metrics which cannot be updated directly, e.g.
   * the number of idle connections in a connection pool
   * can be polled but not updated directly.
   * @param configuration
   * @param state
   */
  fetchMetrics(_: Configuration, __: State): Promise<undefined> {
    return Promise.resolve(undefined);
  },
};

start(connector);

function emitExit(signal: string) {
  const exitCode = 0;
  console.log(`Received "${signal}" signal.`);
  console.log(`Clean up driver.`);
  Neo4j.getInstance()
    .cleanDriver()
    .then(() => {
      console.log(`Terminating...`);
      process.exit(exitCode);
    });
}
process.on("SIGINT", () => emitExit("SIGINT"));
process.on("SIGUSR1", () => emitExit("SIGUSR1"));
process.on("SIGUSR2", () => emitExit("SIGUSR2"));
